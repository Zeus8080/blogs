# 类加载机制

![](E:\blog\blogs\图片\jvm\class_process.jpg)

# 一、概念

类加载器把class文件中的二进制数据读到内存中，存放在方法区，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。具体步骤，如下：

### 1.加载

查找并加载类的二进制数据（把class文件里面的信息加载到内存里面）

### 2.连接

把内存中的二进制数据合并到虚拟机的运行时环境中去

#### （1）验证：确保被加载的类的正确性。包括：

```
 A、类文件的结构检查：检查是否满足Java类文件的固定格式
   B、语义检查：确保类本身符合Java的语法规范
   C、字节码验证：确保字节码流可以被Java虚拟机安全的执行。字节码流是操作码组成的序列。每一个操作码后面都会跟着一个或者多个操作数。字节码检查这个步骤会检查每一个操作码是否合法。
   D、二进制兼容性验证：确保相互引用的类之间是协调一致的。
```

#### （2）准备：为类的静态变量分配内存，并将其初始化为默认值

#### （3）解析

把类中的符号引用转化为直接引用（比如说方法的符号引用，是有方法名和相关描述符组成，在解析阶段，JVM把符号引用替换成一个指针，这个指针就是直接引用，它指向该类的该方法在方法区中的内存位置）

### 3.初始化

为类的静态变量赋予正确的初始值。当静态变量的等号右边的值是一个常量表达式时，不会调用static代码块进行初始化。只有等号右边的值是一个运行时运算出来的值，才会调用static初始化。



## 二、双亲委派模型

![](E:\blog\blogs\图片\jvm\class_loader.jpg)

1、当一个类加载器收到类加载请求的时候，它首先不会自己去加载这个类的信息，而是把该 
请求转发给父类加载器，依次向上。所以所有的类加载请求都会被传递到父类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己尝试去加载该类。当当前类加载器和所有父类加载器都无法加载该类时，抛出ClassNotFindException异常。



2.意义：
提高系统的安全性。用户自定义的类加载器不可能加载应该由父加载器加载的可靠类。（比如用户定义了一个恶意代码，自定义的类加载器首先让系统加载器去加载，系统加载器检查该代码不符合规范，于是就不继续加载了）



3、定义类加载器：如果某个类加载器能够加载一个类，那么这个类加载器就叫做定义类加载器

4、初始类加载器：定义类加载器及其所有子加载器都称作初始类加载器。

5、运行时包：

（1）由同一个类加载器加载并且拥有相同包名的类组成运行时包

（2）只有属于同一个运行时包的类，才能访问包可见（default）的类和类成员。作用是 限制用户自定义的类冒充核心类库的类去访问核心类库的包可见成员。

6、加载两份相同的class对象的情况：A和B不属于父子类加载器关系，并且各自都加载了同一个类。

