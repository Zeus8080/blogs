# 数据结构学习----树 #

**前言：数据结构中树的用途很广，这里记录下学习的过程**
## 一、树的定义 ##
树（tree）是包含n（n>0）个结点的有穷集，其中：<br/>
(1)&nbsp;&nbsp;每个元素称为结点（node）<br/>
(2)&nbsp;&nbsp;有一个特定的结点被称为根结点或树根（root）<br/>
(3)&nbsp;&nbsp;除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，……Tm-1，其中每一个集合Ti（1<=i<=m）本身也是一棵树，被称作原树的子树（subtree）

## 二、相关名词 ##
1.节点的度：一个节点含有的子树的个数称为该节点的度；<br/>
2.叶节点或终端节点：度为0的节点称为叶节点；<br/>
3.非终端节点或分支节点：度不为0的节点；<br/>
4.双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；<br/>
5.孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；<br/>
6.兄弟节点：具有相同父节点的节点互称为兄弟节点；<br/>
7.树的度：一棵树中，最大的节点的度称为树的度；<br/>
8.节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；<br/>
9.树的高度或深度：树中节点的最大层次；<br/>
10.堂兄弟节点：双亲在同一层的节点互为堂兄弟；<br/>
11.节点的祖先：从根到该节点所经分支上的所有节点；<br/>
12.子孙：以某节点为根的子树中任一节点都称为该节点的子孙。<br/>
13.森林：由m（m>=0）棵互不相交的树的集合称为森林；<br/>

## 三、二叉树定义 ##
1.空二叉树--如图(a)<br/>
2.只有一个根节点的二叉树--如图(b)<br/>
3.只有左子树--如图(c)<br/>
4.只有右子树--如图(d)<br/>
5.完全二叉树--如图(e)<br/>
![](http://i.imgur.com/urRkslZ.gif)<br/>
注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。严格来讲，这并不算二叉树的定义只是二叉树的全部可能的情况。

## 四、二叉树的性质 ##
1.在二叉树的第i层上**至多**有2<sup>k-1</sup>个节点;<br/>
2.深度为k的二叉树**至多**有2<sup>k</sup>-1个节点;<br/>
3.对任意一棵二叉树T,如果终端节点数为n<sub>0</sub>,度数为2的节点数为n<sub>2</sub>,则n<sub>0</sub>=n<sub>2</sub>+1;<br/>

## 五、二叉树的遍历实现 ##
### 1.前序遍历 ###
用递归算法实现二叉树的前序遍历
<pre><code>
//二叉树的节点
typedef struct BiTNode{
	TElemType data; //节点数据
	struct BiTNode *lchild, *rchild; //左右孩子指针
} BiTNode, BiTree;

//前序遍历
void PreOrderTraverse(BiTree T){
	if(T == NULL){
		return;
	}
	printf("%c",T->data);
	PreOrderTraverse(T->lchild);
	PreOrderTraverse(T->rchild);
}
</code></pre>

让我们看下遍历的代码是怎么运行的？我们先假设有一棵这样的二叉树，如图：</br>
![](http://i.imgur.com/RpkgYVJ.png)

当调用PreOrderTraverse(T),根节点不为null,执行printf,打印字母A,如图：<br/>
![](http://i.imgur.com/cX2cxfX.png)

调用PreOrderTraverse(T->lchild),访问A节点的左子节点，不为null,执行printf显示字母B，如图：<br/>
![](http://i.imgur.com/9X5BdET.png)

再次递归调用PreOrderTraverse(T->lchild),访问B的左子节点，执行printf显示字母D，如图：<br/>
![](http://i.imgur.com/77a1oBX.png)

再次递归调用PreOrderTraverse(T->lchild),访问D的左子节点，执行printf显示字母H，如图：<br/>
![](http://i.imgur.com/Jl5nLAK.png)

再次递归调用PreOrderTraverse(T->lchild),访问H的左子节点，发现没有，所以T==null，执行return返回此函数，在递归调用PreOrderTraverse(T->rchild),访问H的右子节点，不为null,执行printf显示K，如图：<br/>
![](http://i.imgur.com/CJPEaIp.png)

再次递归调用PreOrderTraverse(T->lchild)，访问K的左子节点，发现没有，执行返回，调PreOrderTraverse(T->rchild)发现右子节点也没有，返回。于是，此函数执行完，返回到上一级递归的函数(也就是打印H节点时的函数)，也执行完毕。返回到打印D节点时的函数，调用PreOrderTraverse(T->rchild)，访问D的右子节点，不存在，返回到B节点，调用PreOrderTraverse(T->rchild)，找到节点E，打印字母E,如图：<br/>
![](http://i.imgur.com/FAA906v.png)

由于节点E没有左右子节点，返回打印B时的递归函数，递归执行完毕，返回到最初PreOrderTraverse，调用PreOrderTraverse(T->rchild);访问节点A的右孩子，打印字母C，如图：<br/>
![](http://i.imgur.com/YxbRqg3.png)

之后类似前面的递归调用，依次打印F、I、G、J
综上，前序遍历这颗二叉树的节点顺序是：A、B、D、H、K、E、C、F、I、G、J

### 2.中序遍历 ###
<pre><code>
//二叉树的节点
typedef struct BiTNode{
	TElemType data; //节点数据
	struct BiTNode *lchild, *rchild; //左右孩子指针
} BiTNode, BiTree;

//中序遍历
void InOrderTraverse(BiTree T){
	if(T == NULL){
		return;
	}
	InOrderTraverse(T->lchild);、
	printf("%c",T->data);
	InOrderTraverse(T->rchild);
}
</code></pre>

### 3.后序遍历 ###
<pre><code>
//二叉树的节点
typedef struct BiTNode{
	TElemType data; //节点数据
	struct BiTNode *lchild, *rchild; //左右孩子指针
} BiTNode, BiTree;

//中序遍历
void PostOrderTraverse(BiTree T){
	if(T == NULL){
		return;
	}
	PostOrderTraverse(T->lchild);、
	PostOrderTraverse(T->rchild);
	printf("%c",T->data);
}
</code></pre>

## 六、线索二叉树 ##
