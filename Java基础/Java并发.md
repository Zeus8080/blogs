## 一、学习路线
![](/图片/并发/Java多线程编程学习体系图.jpg)

## 二、开始学习
### 1.基本概念
#### 1.1线程安全概念
《Java Concurrency In Practice》的作者Brian  Goetz 对"线程安全"有一段定义: 当多个线程访问一个对象的时候, 如果不用考虑这些线程在运行时环境下的调度和交替执行, 也不需要惊醒额外的同步,或者在调用方惊醒任何其他的协调操作,调用这个对象的行为都可以获取正确的结果,那这个对象就是线程安全的. 

##### 1.2线程安全的实现方法
  在写解决方案之前，我们首先要明确，多线程的3个重要特性：<br/>
1.原子性：这一点，跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）;一般来说对基本数据类型的变量的读取和赋值是原子操作,不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性<br/>
2.可见性：指的是当一个线程对共享变量的修改，其他线程能够立即看到。（由于cpu从主存读取数据的效率相对而言并不高，所以现在主流的计算机都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存，实际上写回主内存的时间不可预期。此时其它线程< 特别是不在同一个CPU上执行的线程 >访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。）<br/>
3.顺序性：程序执行的顺序按照代码的先后顺序执行（在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。）<br/>

**线程安全的实现方法**：<br>
1.互斥同步：使用synchronized和锁机制<br>
2.非阻塞同步：基于冲突检测的乐观锁并发策略，简单的理解就是我们先干了再说，如果没有其他线程访问，那么我们的操作就顺利的完成，如果有其他线程访问，并且产生了冲突，那么我们就再来解决冲突，常见的有：(1)volatile变量（提供可见性，不提供原子性）;(2)CAS原子指令，提供可见性和原子性<br>
3.无同步方案：(1)，可重入代码：也叫做纯代码。相对线程安全来说，可以保证线程安全。可以在代码执行过程中中断它，转去执行另一段代码，而在控制权返回后，原来的程序不会出现任何错误；(2)，线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，就可以把共享数据的可见范围限定在同一个线程内，这样无需同步也能保证线程之间不出现数据征用问题。<br>

### 2.锁理论
#### 2.1锁分类
##### 2.1.1自旋锁
自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU,自旋锁又分为简单自旋锁，排队自旋锁，CLH锁，MCS锁具体见识链接。<br/>
[](https://blog.csdn.net/liu88010988/article/details/50799745)
##### 2.1.2公平锁和非公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁。<br/>
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

  



